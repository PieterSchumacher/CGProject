--- 12/02/2020 through 19/02/2020 ---

Goal: Read Wavefront Object, write a .ppm (or other format) image in a perspective

Tasks:
  Camera                        Probably done
  Shape                         Kind of done
  Sphere                        Probably done
  Ray                           Most likely done
  Image file writer             DONE
  Wavefront Object parser
  Material
  Plane
  Pixel? Maybe, must ask. NO

Notes:
  Split into subtasks (this might change for the file format):
    1. write a .ppm with random colours                         DONE
    2. write a sphere with predetermined colours to .ppm        DONE
    3. ray trace a sphere with point light and write to .ppm    DONE
    4. do 3 for a triangles                                     DONE
    5. write a WaveFront Parser and render a triangle           DONE
    6. do 3 for planes, rectangles, meshes                      DONE
    7. think about possible bugs/artefacts and write a draft
        for the report                                          DONE


Questions for assistant:
  Suggestion for image format, prefer an industry standard  -> .ppm or .png or .jpeg
  Way to read Wavefront Object files with notepad/any other application program -> just unzip the file and open
  Find a way to define a working project structure without h2w lib -> for later, must focus on deadline
  Further explanation on the use of a Pixel data structure, and possible other screen/film related things -> Pixel not necessary

image format: .png of openexr
.gz unzippen en dan notepad
zoek op: stack vs heap

19/02/2020:
  Got the intersections working (or atleast to the point where a 2d image renders). Strange bug occurring
  where the sphere moves downwards if the z coordinate is incremented. Need to rethink the way ray directions, cameras
  and hitpoints are represented (in what coordinate systems?). Also: the image isn't taking the plane offset into
  account yet. The ray direction must change accordingly. Maybe ask help tomorrow. Light calculations are strange,
  must somehow be able to multiply and get a value between 0 and 255

20/02/2020:
  -- Questions --
  Do lines like intersection.object->material->kd add a lot of overhead? How to improve?
  Intersection.cpp line intersection = {smallest_t_so_far, n, object, ray}; what to do with object? if the original object gets deleted, will this too?
  What coordinate systems should the ray direction and/or eye be represented in?
  RGB arithmetic, how to retain relative values within 0 and 255
  Best practices for auxiliary functions like get_intersection_color(), within main.cpp or seperate .h/.cpp?
  -- Notes --
  Made progress on color representation. The sphere now reflects light originating from a point light. Must refine shading
  to support material properties. Basic arithmetic operators like + - / * of the rgb struct passed a reference of the original
  object as a result, which resulted in weird bugs. They now return a new copy. Still need to implement gamma correction,
  the correct calculation for a ray direction (i.e. deriving from the camera axes uvw) and new shapes like triangles etc...

21/02/2020:
  -- Notes --
  Wouldn't it be nicer if the origin of the ray was set to the intersection of the direction with the image plane,
  instead of the eye of the camera? That way no check for t >= min_t is needed in intersection calculations.

  Rays now 'shoot' correctly through a camera. Did some refactoring relating to intersection methods.
  The coordinate systems still behave strangely, putting eye at (0, 2.5, -10) gives a pink screen, while (1e-6, 2.5, -10)
  does not.

26/02/2020:
  BVH: First hierarchy of scene, then new hierarchy for triangle mesh OR entire hierarchy for scene? Difference in performance?

27/02/2020:
  Visibility & viewing ray intersections are working for all objects. Optimized triangle intersection. Now writing a
  wavefront obj parser. Next up is anti-aliasing or BVH.
  -- Questions --
  Seemingly left-handedness for eigen vector operations?
  Easy way to parallelize the outer loop?
  Clamping & color representation still not 100% clear
  Difference in complexity between nearest intersection for viewing ray and computing reflected light radiances
  Debugged the wavefront parser. Shading normals are now interpolated according to Phong interpolation.